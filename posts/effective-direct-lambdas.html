<!DOCTYPE html><html lang="en"><head><meta name="robots" content="follow, index"/><meta name="description" content="John Connerton&#x27;s website."/><meta property="og:site_name" content="John Connerton"/><meta property="og:description" content="John Connerton&#x27;s website."/><meta property="og:title" content="John Connerton"/><meta property="og:image"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@yourname"/><meta name="twitter:title" content="John Connerton"/><meta name="twitter:description" content="John Connerton&#x27;s website."/><meta name="twitter:image"/><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"/><link rel="preload" href="/fonts/Inter-roman.latin.var.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><title>Effective Direct Lambdas</title><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/ec0b7c7ab172899c2f46.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ec0b7c7ab172899c2f46.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.6e77778f457ea9996f10.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.91fdd1a0389ed44f92f8.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-37ecd6981e4ed6beb056.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-e330297c2ef11714f651.js" as="script"/><link rel="preload" href="/_next/static/chunks/9341d7c4832bf9246b49aba1a6a01752c9539666.1732232d3be8a53f1c9b.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/effective-direct-lambdas-ddba86ebdf6c4ab9d238.js" as="script"/><style id="__jsx-791102496">a.jsx-791102496{float:right;}@media screen and (max-width:480px){article.jsx-791102496{padding-top:2rem;padding-bottom:4rem;}}</style></head><body><div id="__next"><article class="container prose prose-sm md:prose"><h1>Let there be an API!</h1><div class="meta-line"><div class="meta">John Connerton<!-- -->, <time>Fri Jul 31 2020</time> • <a class="tag" href="/tags/tutorials">tutorials</a></div><a class="meta-back" href="/posts">Back</a></div><p>Today, I’m going to walk you through using AppSync’s Direct Lambda feature. I helped build it this Summer after all, so I should be able to express how simple, yet effective, this feature is in allowing you to configure Lambdas for your API on AppSync.</p><p><em>Go ahead and jump to the section labelled <strong>Let there be an API!</strong> if you’d like to skip the bits about what the old workflow for a Lambda resolver was like.</em></p><p>I’d first like to make a point about why Direct Lambdas were necessary. Here&#x27;s a picture to help demonstrate that point.</p><p><img src="https://miro.medium.com/max/1000/1*wO5RuITG7uP0HO8hLn0CRQ.png" alt="VTL? Cancelled, sorta. Call the mob."/></p><p>In order to set up a Lambda resolver for a field on AppSync, you’d first have to check out the <a href="https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-lambda.html">resolver mapping template reference</a>, then you’d have to set up your mapping templates in a language called VTL. These templates translate data back and forth between your Lambda. Finally, you’d be able to set up your Lambda to expect the data as translated by the mapping templates.</p><p>Notice that I mentioned that you had to write code in two separate places: the Lambda and the mapping templates, which might be in the Appsync console editors, uploaded through the SDK, or in a CloudFormation template. This introduces unnecessary coupling between your Lambda code and your mapping templates, which is probably not optimal for your code-base, nor your mental health.</p><p>This is where the problem lies: if it’s at all complicated, then it’s too complicated. The goal is to think less… Er, less about things that don’t matter, that is.</p><p>If only there was an easier way to configure a Lambda resolver on AppSync. If only there was a way to write less code and get more done.</p><p>There is now a way, <strong>Direct Lambdas</strong>.</p><p>I’d like to avoid making this tutorial dry and boring so I’ve decided that our API will be all about awesome, original, <strong><em>definitely-not-cringe</em></strong> dad jokes! Plus, we can utilize a friendly API called <a href="https://icanhazdadjoke.com/api">icanhazdadjokes</a> that offers an unprecedented collection of definitely-not-cringe-worthy dad jokes for free. That’s a low price!</p><p>Let’s start off with a specification of what our API should do. I’d like to create an API that will allows a client to either get a random Joke or get a Joke specified by an ID.</p><h4>What makes up a Joke?</h4><ul><li><p>joke: The content of the joke</p></li><li><p>id: The id of the joke</p></li><li><p>imageUrl: A permalink to the joke</p></li><li><p>cringe: A boolean that shows if the joke is cringe or not</p></li></ul><p>Here’s how the entire thing will work:</p><p><img src="https://cdn-images-1.medium.com/max/1618/1*kwEgdbRG5OOlTzZS-Lj7FQ.png" alt="This diagram is clunky, but it gets the job done."/></p><p>If you’d like to follow along, go ahead and open up the AWS console and go to the AppSync service. Create a new API, click ‘build it from scratch’, and name it something accurate like, “Personality Generator”.</p><p>Pop into the ‘Schema’ tab and overwrite whatever is in the editor with this:</p><pre><code>type Joke {
    id: ID!
    joke: String!
    cringe: Boolean!
    imageUrl: String!
}

type Query {
    hurryAndGiveMeADadJoke: Joke
    giveMeADadJoke(id: ID!): Joke
}
</code></pre><p>Then head over to the Lambda service, which is where we will create a Lambda function. Keep your region in mind. You can find it in the URL on the Lambda service dashboard. We will need it later on in the tutorial.</p><p>Go ahead and click on ‘Create function’ and fill out the name under the ‘Author from scratch’ selection with something like “Does_The_Thing”. Make sure that the selected runtime is Node.js 12.x, which is what we are using for this tutorial. Direct Lambdas are available in any runtime, so don’t fret if you’d prefer using a different language.</p><p>At this point. click ‘Create function’ at the bottom of the page and then put this starter code into the editor and click the ‘save’ button on the top right of the page.</p><pre><code>exports.handler = (event, context, callback) =&gt; {
    console.log(event);
};
</code></pre><p>Head back to the AppSync console and switch over to the ‘Data Sources’ tab. We’re going to create a new data source, which will point to the Lambda function we just created! Click on ‘Create data source’ and fill out the form like this:</p><p><img src="https://cdn-images-1.medium.com/max/3138/1*gpZ12Nazs3WOzw0DX-5N0A.png" alt="Hopefully you enjoy my quick GIMP edit!"/></p><p>This will create a data source named Does_The_Thing that is connects to the Lambda function we created earlier. Then, it creates a role that will allow AppSync to use the Lambda.</p><p>Now, we get to do the fun stuff! We can configure this Lambda to be used as a resolver. Head on back to the ‘Schema’ tab. We’re going to attach this new data source to resolver of the fields <strong>imageUrl</strong>, <strong>hurryAndGiveMeADadJoke</strong>, and <strong>giveMeADadJoke</strong>. So, for all of those follow these steps:</p><ul><li><p>In the Resolvers section of the Schema, go to the field you wish to attach the Lambda to.</p></li><li><p>Click ‘Attach’!</p></li><li><p>In the Resolver Editor Page, find and select our new Lambda data source from the drop-down.</p></li><li><p>Make sure that the two toggles are off, signalling that AppSync will not use any mapping templates.</p></li></ul><p><img src="https://cdn-images-1.medium.com/max/3142/1*KTJrER-oFVQu90p3Ni2_uQ.png" alt=""/></p><p>If it looks like the picture above, click ‘Save resolver’. Go ahead and do that same thing for the other two fields I mentioned earlier.</p><p>Now we can finally make a query! Head over to the ‘Queries’ tab on the AppSync console and put this into the editor:</p><pre><code>{
  hurryAndGiveMeADadJoke {
    imageUrl
    id
    joke
    cringe
  }
  
  giveMeADadJoke(id: &quot;9EBljqWDAsc&quot;) {
    imageUrl
    joke
    cringe
  }
}
</code></pre><p>Then send that query off (at the time of writing, you just click the little orange play button) and… <strong>Oh no!</strong> We get this:</p><pre><code>&quot;data&quot;: {
    &quot;hurryAndGiveMeADadJoke&quot;: null,
    &quot;giveMeADadJoke&quot;: null
  }
</code></pre><p>Luckily, this response was expected, since we never did anything useful with the Lambda. Right now, our Lambda only prints out the event object passed in from AppSync.</p><p>We should head over to the Lambda editor we left open earlier and then to the monitoring tab which allows us to view our logs from CloudWatch. The logs will show the event object we printed out when we made our last query. If you don’t want to click that many times, or are simply just following along here is what the event object looks like for me:</p><p><img src="https://cdn-images-1.medium.com/max/1452/1*z88ag2qIdNsqyJpRnRAy7Q.png" alt=""/></p><p>Now that you know what is contained in the event object when the cringe field is invoked (it’s just the <a href="https://docs.aws.amazon.com/appsync/latest/devguide/resolver-context-reference.html">AppSync Context object</a>), we can go ahead and finish filling out the Lambda function in the Lambda console. Here’s some logic that should work for us:</p><pre><code>const https = require(&#x27;https&#x27;);

/* The event object contains a bunch of special goodies!
Those goodies are explained in more detail in the AppSync Mapping Template Reference for Lambdas.
We will use only a few of the fields in this example. */
    
exports.handler = (event, context, callback) =&gt; {
    console.log(event);
    
    const options = {
        host: &#x27;icanhazdadjoke.com&#x27;,
        method: &#x27;GET&#x27;,
        headers: { &#x27;Accept&#x27;: &#x27;application/json&#x27; }
    };
    
    // The next line shows off how you can access the info object, which contains all sorts of exciting stuff
    // pertaining to the GraphQL query.
    switch (event.info.fieldName) {
        case &#x27;hurryAndGiveMeADadJoke&#x27;:
            console.log(&#x27;Getting a random dad joke.&#x27;);
            getRequest(options, callback);
            return;
        
        // Here we use the arguments object passed in by AppSync. 
        case &#x27;giveMeADadJoke&#x27;:
            console.log(`Getting the joke with ID: ${event.arguments.id}`);
            options[&#x27;path&#x27;] = `/j/${event.arguments.id}`;
            getRequest(options, callback);
            return;
            
        // For this field, we get to use the source object! 
        // Source contains the data belonging to the parent object for this current field.
        case &#x27;imageUrl&#x27;:
            console.log(`Returning the image url for the dad joke ${event.source.id}`);
            const imgUrl = `https://icanhazdadjoke.com/j/${event.source.id}.png`;
            callback(null, imgUrl);
            return;
            
        case &#x27;cringe&#x27;:
            console.log(&#x27;All dad jokes are cringe.&#x27;);
            callback(null, true);
            return;
            
        default:
            callback(`Sorry pal, we can&#x27;t do anything for the field: ${event.info.fieldName}`);
    }
};

// This thing uses https to get the info we need, then calls the callback we pass in!
// https is super clunky looking, but it&#x27;s built into Node, so it&#x27;s easy to use.
const getRequest = (options, callback) =&gt; {
    https.get(options, (res) =&gt; {
        let body = &#x27;&#x27;;
    
        res.on(&#x27;data&#x27;, (d) =&gt; {
            body += d;
        });
        
        res.on(&#x27;end&#x27;, () =&gt; {
            body.trim();
            callback(null, JSON.parse(body));
        });
    
    })
    .on(&#x27;error&#x27;, (err) =&gt; {
      callback(err);
    });
};
</code></pre><p>This will handle resolving all the fields that we currently have set up. One thing that I’d like to note is that the <strong>event</strong> object and the **callback **function are both sent from AppSync.</p><p>The callback responds with the result of the resolver, but the actual data is passed into the the 2nd parameter of the callback, the first parameter is used for responding with errors, as you can see in the default case within the switch.</p><p>The event object holds a bunch of goodies we checked out in the logs earlier! Here are some of the goodies that we used in our Lambda:</p><ul><li><p>event.info holds the field name that is currently being resolved.</p></li><li><p>event.arguments holds all the arguments passed into query.</p></li><li><p>event.source has the data belonging to the resolved parent object for this current field.</p></li></ul><p>To learn more about those goodies and all the other stuff in the event object, check out the <a href="https://docs.aws.amazon.com/appsync/latest/devguide/resolver-context-reference.html">Resolver Mapping Template Context Reference</a>.</p><p>Hopefully, everything within the rest of the Lambda is easy to understand, but take a moment to read through and understand what’s happening when we invoke this Lambda.</p><p>Let’s head back to the Query page on the AppSync console. Run that same query we ran before and… hooray!</p><pre><code>{
  &quot;data&quot;: {
    &quot;hurryAndGiveMeADadJoke&quot;: {
      &quot;imageUrl&quot;: &quot;https://icanhazdadjoke.com/j/ciiNuXDY0wc.png&quot;,
      &quot;id&quot;: &quot;ciiNuXDY0wc&quot;,
      &quot;joke&quot;: &quot;Where did Captain Hook get his hook? From a second hand store.&quot;,
      &quot;cringe&quot;: true
    },
    &quot;giveMeADadJoke&quot;: {
      &quot;imageUrl&quot;: &quot;https://icanhazdadjoke.com/j/9EBljqWDAsc.png&quot;,
      &quot;joke&quot;: &quot;What do you call a fish with no eyes? A fsh.&quot;,
      &quot;cringe&quot;: true
    }
  }
}
</code></pre><p>We’ve successfully set up an API that does everything we set out to do and we’ve done so without all the VTL for the resolver mapping templates! Now <strong>you</strong> know how to effectively use Direct Lambdas on AppSync.</p><p>If you’d like to walk through AppSync’s reference on Direct Lambdas, check out the <a href="https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-lambda.html">Resolver Mapping Template Reference for Lambdas</a> or the configuring <a href="https://docs.aws.amazon.com/appsync/latest/devguide/direct-lambda-reference.html">Direct Lambda section in the AppSync documentation</a>. Ed Lima, a Sr. product manager at AWS also created an<a href="https://aws.amazon.com/blogs/mobile/appsync-direct-lambda/"> awesome blog post</a> that covered using Direct Lambdas in a few different languages.</p><p>Now, keep in mind, Direct Lambdas can only be used in Lambda resolvers and miss some of the awesome functionality the VTL allow, so there are still plenty of use-cases for it, even with the existence of Direct Lambdas.</p><p>I hope this example helps you figure out how to use AppSync’s Direct Lambda feature to create a GraphQL API. I believe that it allows developers to write less code and get more done. Let me know how effective you think they are!</p><hr/><p>Feel free to connect with me!</p><p><a href="https://www.linkedin.com/in/johnconnerton/">LinkedIn</a></p><p><a href="https://twitter.com/conjohnert">Twitter</a></p><p><a href="https://github.com/conjohnerton">GitHub</a></p><small style="display:block;margin-top:8rem" class="jsx-791102496"><time class="jsx-791102496">2021</time> © John Connerton.<a href="/feed.xml" class="jsx-791102496">RSS</a></small></article></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/posts/effective-direct-lambdas","query":{},"buildId":"rD45q_7oTnFbI0VXh_sym","nextExport":true,"autoExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/chunks/polyfills-ff94e68042added27a93.js"></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.6e77778f457ea9996f10.js" async=""></script><script src="/_next/static/chunks/commons.91fdd1a0389ed44f92f8.js" async=""></script><script src="/_next/static/chunks/main-37ecd6981e4ed6beb056.js" async=""></script><script src="/_next/static/chunks/pages/_app-e330297c2ef11714f651.js" async=""></script><script src="/_next/static/chunks/9341d7c4832bf9246b49aba1a6a01752c9539666.1732232d3be8a53f1c9b.js" async=""></script><script src="/_next/static/chunks/pages/posts/effective-direct-lambdas-ddba86ebdf6c4ab9d238.js" async=""></script><script src="/_next/static/rD45q_7oTnFbI0VXh_sym/_buildManifest.js" async=""></script><script src="/_next/static/rD45q_7oTnFbI0VXh_sym/_ssgManifest.js" async=""></script></body></html>